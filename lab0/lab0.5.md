

# Lab0.5：最小可执行内核

从oslab网站上取得实验代码后，进入目录labcodes/lab0，完成实验要求的各个练习。在实验报告中回答所有练习中提出的问题。将实验代码和报告上传到小组仓库中。推荐用**markdown**格式。对于lab1中编程任务，完成编写之后，再通过git push命令把代码同步回git server网站。最后请一定提前或按时提交到git server网站。

注意有“LAB0.5”的注释，代码中所有需要完成的地方（challenge除外）都有“LAB0.5”和“YOUR CODE”的注释，请在提交时特别注意保持注释，并将“YOUR CODE”替换为自己的学号，并且将所有标有对应注释的部分填上正确的代码。

对实验报告的要求：

- 基于markdown格式来完成，以文本方式为主

- 填写各个基本练习中要求完成的报告内容

- 列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）

- 列出你认为OS原理中很重要，但在实验中没有对应上的知识点

#### 练习1: 使用GDB验证启动流程

Q：使用gdb调试QEMU模拟的RISC-V计算机加电开始运行到执行应用程序的第一条指令（即跳转到`0x80200000`）这个阶段的执行过程，说明RISC-V硬件加电后的几条指令在哪里？完成了哪些功能？要求在报告中简要写出练习过程和回答。

A：采用gdb进行调试：
```assembly
(gdb) x/10i $pc
=> 0x1000: auipc t0,0x0
     0x1004: addi a1,t0,32
     0x1008: csrr a0,mhartid
     0x100c: ld t0,24(t0)
     0x1010: jr t0
     0x1014: unimp
     0x1016: unimp
     0x1018: unimp
     0x101a: 0x8000
     0x101c: unimp
```

`0x1000` 是一个复位地址，根据 QEMU 的源码，在 `target/riscv/cpu.c` 中发现将宏定义 `DEFAULT_RSTVEC` 的值赋给了 `resetvec`，而宏定义的值即为 `0x1000`，`resetvec` 的值又被赋给了 `pc`，说明CPU就是从 `0x1000` 处开始执行代码的。

这段代码的源码可以在 QEMU 的 `hw/riscv/virt.c` 中找到，做的事情主要是：

1. 将这段代码的基地址 `0x1000` 载入 `t0` 寄存器；
2. 将当前的 `mhartid` 载入 `a0` 寄存器；
3. 跳转到 `0x8000`。

riscv-virt 是 QEMU 提供的虚拟开发板，用于模拟 RISC-V 架构的虚拟硬件环境。在 `hw/riscv/virt.c` 文件中，查看内存映射，有：

```assembly
static const struct MemmapEntry {
    hwaddr base;
    hwaddr size;
} virt_memmap[] = {
    [VIRT_DEBUG] =       {        0x0,         0x100 },
    [VIRT_MROM] =        {     0x1000,       0x11000 },
    [VIRT_TEST] =        {   0x100000,        0x1000 },
    [VIRT_CLINT] =       {  0x2000000,       0x10000 },
    [VIRT_PLIC] =        {  0xc000000,     0x4000000 },
    [VIRT_UART0] =       { 0x10000000,         0x100 },
    [VIRT_VIRTIO] =      { 0x10001000,        0x1000 },
    [VIRT_DRAM] =        { 0x80000000,           0x0 },
    [VIRT_PCIE_MMIO] =   { 0x40000000,    0x40000000 },
    [VIRT_PCIE_PIO] =    { 0x03000000,    0x00010000 },
    [VIRT_PCIE_ECAM] =   { 0x30000000,    0x10000000 },
};

```

第一个参数为硬件映射的地址，第二个参数为映射的内存长度，可以看到，DRAM 的内存起始地址是 `0x80000000`；随后，`virt.c` 中指定了将 bootloader 加载到 DRAM 的起始地址上，即 bootloader 被放到了 `0x80000000`。

结合此前 gdb 调试的结果，可以知道在 RISC-V 处理器中，有一个内置的 ROM 用来存放复位代码，RISC-V上电时先跳转到 `0x1000` 处执行复位代码，接着在代码的 `0x1010` 处指定将 `pc` 跳转到 `0x80000000` ，开始执行放在那里的 bootloader（在本实验中，即默认的 openSBI）。

openSBI 接手后，会完成内核运行环境的初始化，把 CPU 从 M Mode 切换到 S Mode 后，将内核代码加载到内存中。加载内核的基地址可以在 `hw/riscv/boot.c` 中找到，对于 RISC-V 64 平台，定义 `KERNEL_BOOT_ADDRESS = 0x80200000`。查看链接脚本 `kernel.ld`，开头就规定了基地址 `BASE_ADDRESS=0x80200000`，从这里开始放置各个段。

此后，为了正确地和内核对接，openSBI 也需要把 `pc` 跳转到 `0x80200000` 处作为程序的入口点，操作系统在此开始执行；具体地说，链接脚本里指定了 `ENTRY(kern_entry)`，这里就是整个内核的入口点，在这里进行内核栈的分配，然后转入C语言编写的内核初始化函数 `kern_init`。

#### 讲解中出现的问题

**地址无关代码**

"地址无关代码"（Position-Independent Code，PIC）是一种在计算机程序中的编程技术，其主要目的是使程序可以在内存中加载到不同的地址并仍然正常运行。这对于操作系统和编程语言的设计非常重要，因为它允许程序在不同的内存地址上执行，而不需要进行重定位或修改程序的源代码。

以下是关于地址无关代码的一些重要概念和用途：

1. 内存地址随机化（ASLR）：地址无关代码的一个重要应用是与内存地址随机化（ASLR）结合使用。ASLR 是一种安全机制，它随机地分配程序的内存地址，以增加恶意攻击者对程序的攻击难度。地址无关代码可以在这种环境中正常工作，因为它不依赖于特定的内存地址。

2. 共享库和动态链接：地址无关代码在共享库和动态链接中特别有用。共享库是一组可以由多个程序共享的函数和资源，而动态链接允许程序在运行时加载这些共享库。地址无关代码确保这些库可以加载到任何可用的内存地址，而无需修改程序的代码。

3. 移植性：使用地址无关代码编写的程序更容易在不同的操作系统和硬件平台上移植，因为它们不依赖于特定的内存布局或地址分配策略。

4. 编程技术：地址无关代码通常需要使用特定的编程技术和工具，例如汇编语言中的位置无关指令、链接器选项和编译器选项。这些技术确保程序在加载时能够自动进行必要的地址计算和修正。

**程序的链接地址和加载地址为何需要统一：**

1. 数据一致性：在执行"store"指令时，它需要将数据写入特定的内存位置。如果程序的链接地址和加载地址不一致，就会导致数据存储的位置混乱，这可能会导致程序无法正常运行或产生不可预测的错误。通过统一链接地址和加载地址，确保了数据存储的一致性，使得"store"指令可以正确地将数据写入目标内存位置。

2. 指令和数据的一致性：在某些架构中，指令和数据存储在不同的内存区域。如果程序的链接地址和加载地址不一致，可能会导致指令和数据的一致性问题，这会对程序的执行产生严重影响。通过统一链接地址和加载地址，可以确保指令和数据在正确的内存位置上。

3. 代码重定位：一些操作系统或程序加载器需要执行代码重定位，以便在运行时将程序加载到内存的不同位置。然而，在内核层面，这种重定位通常会在加载之前进行。如果链接地址和加载地址不一致，内核需要实现复杂的重定位逻辑，这可能会增加内核的复杂性和性能开销。

内核设计简单性：与程序重定位类似，内核的设计可以更加简单和高效，如果它不必处理链接地址和加载地址不一致的情况。这有助于内核的可维护性和可移植性。